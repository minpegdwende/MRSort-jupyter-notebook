from __future__ import division
import os, sys
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)) + "/../../")
import random
from pymcda.types import AlternativePerformances
from pymcda.types import PerformanceTable
from collections import OrderedDict

class HeurMRSortInitVetoProfiles():

    def __init__(self, model, pt_sorted, aa):
        self.model = model
        self.pt_sorted = pt_sorted
        self.aa = aa
        self.delta = 0.0000001
        self.b0 = pt_sorted.pt.get_worst(self.model.criteria)
        self.compute_categories_probabilities()

    def compute_categories_probabilities(self):
        self.cat_proba = {}
        total = len(self.aa)
        for cat in self.model.categories:
            aa_cat = self.aa.get_alternatives_in_category(cat)
            self.cat_proba[cat] = total - len(aa_cat)

    def compute_histogram(self, crit, cat_above, cat_below):
        h1 = {}
        h2 = {}
        above = self.model.bpt['b1'].performances[crit.id]
        below = self.b0.performances[crit.id]
        aids, perfs = self.pt_sorted.get_middle(crit.id, below, above)

        delta = self.delta * crit.direction

        # From smallest to biggest
        val = 0
        for aid, perf in zip(aids, perfs):
            cat = self.aa[aid].category_id
            if cat == cat_above:
                val += self.cat_proba[cat]
                h1[perf + delta] = val
            elif cat == cat_below:
                h1[perf] = val

        # From biggest to smallest
        val = 0
        aids.reverse()
        perfs.reverse()
        for aid, perf in zip(aids, perfs):
            cat = self.aa[aid].category_id
            if cat == cat_below:
                val += self.cat_proba[cat]
                h2[perf] = val
            elif cat == cat_above:
                h2[perf + delta] = val

        return { key: h1[key] + h2[key] for key in h1 }

    def weighted_choice(self, h):
        total = sum(h.values())
        r = random.uniform(0, total)
        tmp = 0
        for perf, proba in h.items():
            tmp += proba
            if tmp > r:
                break

        return perf

    def init_profile(self, profile_id, cat_above, cat_below):
        ap = AlternativePerformances(profile_id, OrderedDict({}))
        for c in self.model.criteria:
            h = self.compute_histogram(c, cat_above, cat_below)
            if h:
                perf = self.weighted_choice(h)
            ap.performances[c.id] = perf

        return ap

    def solve(self):
        cats = self.model.categories[:]
        cats.reverse()

        profiles = self.model.profiles[:]
        profiles.reverse()

        vpt = PerformanceTable()
        pabove = self.pt_sorted.pt.get_best(self.model.criteria)
        for i in range(len(cats) - 1):
            profile_id = profiles[i]
            b1 = self.model.bpt['b1']
            vp = self.init_profile(profile_id, cats[i], cats[i+1])
            vpt.append(b1 - vp)

        self.model.veto = vpt

if __name__ == "__main__":
    from pymcda.generate import generate_random_mrsort_model
    from pymcda.generate import generate_alternatives
    from pymcda.generate import generate_random_performance_table
    from pymcda.generate import generate_random_profiles
    from pymcda.pt_sorted import SortedPerformanceTable
    from pymcda.utils import compute_ca
    from pymcda.utils import compute_winning_and_loosing_coalitions
    from pymcda.utils import display_coalitions
    from pymcda.learning.lp_mrsort_weights import LpMRSortWeights
    from pymcda.ui.graphic import display_electre_tri_models

    model = generate_random_mrsort_model(10, 2, 1)

    a = generate_alternatives(1000)
    pt = generate_random_performance_table(a, model.criteria)
    sorted_pt = SortedPerformanceTable(pt)

    aa = model.pessimist(pt)

    # Learn the veto weights with profiles generated by the heuristic
    model3 = model.copy()
    heur = HeurMRSortInitVetoProfiles(model3, sorted_pt, aa)
    heur.solve()

    print(model3.veto)
